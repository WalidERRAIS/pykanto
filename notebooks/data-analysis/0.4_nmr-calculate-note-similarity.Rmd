---
title: "Build RF similarity matrix for each note in the dataset"
author: "Nilo Merino Recalde<br>"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  github_document:
    toc: true
    toc_depth: 4
editor_options:
  chunk_output_type: console
---
<br>

# Settings and paths
```{r setup}
# Knitr settings: 
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
knitr::opts_chunk$set(echo = TRUE, eval = FALSE)
options(scipen = 999)
```

```{r}
# Code to calculate acoustic distances
#NOTE: this code will not make new measurements, calculate distances, etc, 
# if the corresponding output files already exist; 
# if you want to recalculate, delete the files before running

# Settings and paths --------------------------------------
# # clear the R workspace
# rm(list = ls())

x <- gc()
x <- c(
    "parallel",
    "vegan",
    "bioacoustics",
    "warbleR" ,
    "ggplot2",
    "Rraven",
    "cluster",
    "randomForest",
    "MASS",
    "fossil",
    "pbapply",
    "adehabitatHR",
    "Sim.DiffProc",
    "caret",
    "e1071",
    "tidyverse",
    "pracma",
    'dtwclust',
    'fastcluster',
    'dynamicTreeCut',
    'dbscan',
    'ggraph',
    'tidygraph',
    'progressr',
    'reshape2',
    'Matrix'
  )

# load packages 
aa <- lapply(x, function(y) {
  if (!y %in% installed.packages()[, "Package"])  {
    install.packages(y)
  }
  try(require(y, character.only = T), silent = T)
})

# Paths
root.dir = rprojroot::find_rstudio_root_file()
# dataset_name <-  "GRETI_HQ_2020_joined_notes_test" #! remove _test after done #!
dataset_name <-  "GRETI_HQ_2020_joined_notes" #! change to this if not test

data_dir <-  file.path(root.dir, "data", "processed", dataset_name, 'WAV')
out_dir = file.path(root.dir, "data", 'note_dfs', dataset_name)
coords_dir = file.path(getwd(), "resources", "nestboxes", "nestbox_coords.csv")
dom_freqs_name <- file.path(out_dir, 'dominant_frequencies.RDS')
dtw_dist_name <- file.path(out_dir, 'dtw_dist.RDS')

est.file.name <- file.path(out_dir, 'selection_table.RDS')
specs_dir <-  file.path(out_dir, 'spectrograms')

if (!dir.exists(specs_dir)) {
  dir.create(specs_dir, recursive = TRUE)
}

ncores = parallel::detectCores() - 1


# WarbleR options
warbleR_options(
  wav.path = data_dir,
  f = 22050,
  wl = 512,
  flim = c(2, 8.5),
  ovlp = 95,
  bp = c(2, 8.5),
  parallel = ncores
)

# Functions
stdize = function(x, ...) {(x - min(x, ...)) / (max(x, ...) - min(x, ...))}
```

# Make or load selection table
```{r}

if (file.exists(est.file.name)) {
  load(est.file.name)
} else {
  wi <- wav_info()
  summary(wi)
  est <- selection_table(whole.recs = T, extended = T, confirm.extended = F)
  save(est,file=est.file.name)
}

```

# Extract dominant frequencies
```{r}
#DTW
# dom_freqs$sound.files <-
#   lapply(dom_freqs$sound.files, function(x)
#     gsub("\\..*", "", x))

# Extract dominant frequency, save

if (file.exists(dom_freqs_name)) {
  load(dom_freqs_name)

} else {
  dom_freqs <- dfts(est,
      pb = TRUE,
      parallel = ncores,
      img = T,
      threshold.time = 3,
      threshold.freq = 3,
      fsmooth = 0.2,
      clip.edges = TRUE,
      track_harm = TRUE, 
      length.out = 20)
  
  save(dom_freqs, file=dom_freqs_name)
}
```

# Calculate DTW distances
```{r}
# dom_freqs %>% slice(36) %>% gather() %>% slice(3:nrow(.)) %>% select(value) %>%  plot() # check one trace

# Calculate DTW distances, save
if (file.exists(dtw_dist_name)) {
  load(dtw_dist_name)
} else {
  with_progress(system.time(dtw_dist <- proxy::dist(dom_freqs[c(-1,-2)], method = "DTW_BASIC", norm = "L2", window.size = 10))) # series are of same length so distances are symmetric even with a window applied
  dtw_dist_matrix = as.matrix(dtw_dist) %>% stdize() # convert to matrix and range 0-1
  rownames(dtw_dist_matrix) = dom_freqs$sound.files
  colnames(dtw_dist_matrix) = dom_freqs$sound.files
  save(dtw_dist_matrix, file=dtw_dist_name)
}

# heatmap(dtw_dist_matrix)
dtw_dist_matrix[!is.finite(dtw_dist_matrix)] # check that there are no infinites

```

# Clustering
```{r}
# Hierarchical clustering
DTWdist = as.dist(dtw_dist_matrix)
dendrogram = hclust(DTWdist, method = "average")
clusters <-
  cutreeDynamic(
    dendrogram,
    distM = as.matrix(DTWdist),
    deepSplit = 3,
    # This works well (i.e. cluster membership makes sense)
    minClusterSize = 4, # Set to smallest sample size for any song type
    method = 'hybrid',
    verbose = 4
  )

print(str_glue('Number of clusters: {length(unique(clusters))}'))
cluster_membership = tibble(file = dom_freqs$sound.files, cluster = clusters) %>% 
  mutate(name = lapply(file, function(x)
  gsub("\\..*", "", x))) %>% 
  mutate(note = gsub('-[^-]*$', '', name), bird = gsub('-[^-]*', '', name))

# HDBSCAN clustering
# detects song types by bird very well, but this is not what we want - need a more relaxed solution, like above
# hdbscan_clusters = hdbscan(DTWdist, minPts = 4)
# plot(hdbscan_clusters, show_flat = TRUE)
# plot(DTWdist, col=hdbscan_clusters$cluster+1L, cex = .5)
# plot(hdbscan_clusters$hc, main="HDBSCAN* Hierarchy")
# cluster_membership = cluster_membership %>% mutate(hdbscan_cluster = hdbscan_clusters$cluster)
```

# Prepare song sharing data
```{r}
# Build song-sharing matrix
summary_songs = cluster_membership %>% distinct(note, cluster, .keep_all = TRUE)
match_matrix = as.matrix(dist(summary_songs$cluster, upper=TRUE, diag=FALSE))
match_matrix[match_matrix > 0] <- NA
match_matrix[match_matrix == 0] <- 1
match_matrix[is.na(match_matrix)] <-  0
diag(match_matrix) <- 0
rownames(match_matrix) = summary_songs$bird
colnames(match_matrix) = summary_songs$bird

# Number of shared songs (losing info about which)
shared_matrix = rowsum(match_matrix, row.names(match_matrix), reorder = FALSE)
shared_table = as_tibble(shared_matrix, .name_repair="minimal")
shared_matrix = as.matrix(do.call(cbind, by(t(shared_table),INDICES=names(shared_table),FUN=colSums)))
rownames(shared_matrix) = colnames(shared_matrix)

diag(shared_matrix) <- 0
shared_matrix = as.matrix(tril(shared_matrix))
```

# Acoustic distance vs spatial distance
```{r}
library(usedist)

dists = as.dist(dtw_dist_matrix)
labs = cluster_membership$note

# Pairwise average DTW distances (by song)
song_mean_a_dist = dist_groups(dists, labs) %>% 
  janitor::clean_names() %>% 
  group_by(label) %>% 
  mutate(mean_a_dist = mean(distance)) %>% 
  ungroup() %>% 
  select(-distance,-item1, -item2) %>% 
  distinct(group1, group2, mean_a_dist, .keep_all = TRUE) %>% 
  separate(group1, into = c("bird1", "note1"), sep = "-", remove = FALSE) %>% 
  separate(group2, into = c("bird2", "note2"), sep = "-", remove = FALSE)

rm(dists, labs); gc()

# Pairwise average DTW distances (by bird)
bird_mean_a_dist = song_mean_a_dist %>% 
  group_by(bird1, bird2) %>% 
  mutate(mean_a_dist = mean(mean_a_dist)) %>% 
  ungroup() %>% 
  select(bird1, bird2, mean_a_dist) %>% 
  distinct(.keep_all = TRUE)

birds = cluster_membership$bird %>% unique()

# Get nestbox coordinates, prepare data
nest_coords = read_csv(coords_dir) %>% filter(nestbox %in% birds) # only keep relevant birds
new_order <-
  sapply(birds, function(x, nest_coords) {
    which(nest_coords$nestbox == x)
  }, nest_coords)
coords <- nest_coords[new_order,] %>% distinct(nestbox, .keep_all = TRUE)
space_dist_matrix = as.matrix(dist(coords[0:2], upper = T))
rownames(space_dist_matrix) = birds
colnames(space_dist_matrix) = birds
spatial_dist_data = as.dist(space_dist_matrix)
spatial_dist_data = dist_groups(spatial_dist_data, birds) %>% 
  janitor::clean_names() %>% 
  rename(bird1 = item1, bird2 = item2, s_dist = distance) %>% 
  select(-group1, -group2, -label) %>% 
  as.tibble()

# Build dataframes by song, bird, and sharing
distances_by_shared_song = inner_join(distances_by_song, cluster_membership, by = c("group1" = "note")) %>% 
  inner_join(., cluster_membership, by = c("group2" = "note")) %>% 
  select(-bird.x, -bird.y, -name.x, -name.y) %>% 
  rename(cluster1 = cluster.x, cluster2 = cluster.y)

distances_by_song = inner_join(song_mean_a_dist, spatial_dist_data, by=c('bird1', 'bird2')) # removing within bird comparison
distances_by_bird = inner_join(bird_mean_a_dist, spatial_dist_data, by=c('bird1', 'bird2')) # removing within bird comparison

# Sharing/not sharing vs distance
n_songs_per_bird = song_mean_a_dist %>% distinct(bird1, note1) %>% group_by(bird1) %>% tally()

sharing_df = melt(shared_matrix, varnames = c("bird1", "bird2")) %>% 
  rename(n_shared = value, bird1= bird2, bird2=bird1) %>% 
  left_join(., spatial_dist_data) %>% 
  separate(bird1, 
           into = c("area1", "num"), 
           sep = "(?<=[A-Za-z])(?=[0-9])", remove = FALSE) %>% 
  separate(bird2, 
           into = c("area2", "num"), 
           sep = "(?<=[A-Za-z])(?=[0-9])", remove = FALSE) %>% 
  mutate(area = case_when(area1 == area2 ~ area1)) %>% 
  select(-num, -area1, -area2) %>% 
  as_tibble() %>% # Add number of song types per bird, calculate sharing index
  full_join(., n_songs_per_bird) %>% 
  full_join(., n_songs_per_bird, by = c('bird2' = 'bird1'), suffix = c("1", "2")) %>% 
  # filter(s_dist < 400) %>% # Keep only close neighbours 
  mutate(jaccard = n_shared/(n1+n2)) %>% 
  as_tibble() %>% 
  drop_na(s_dist)

# Average jaccard index by bird
mean_jaccard = sharing_df %>% group_by(bird1) %>% 
  mutate(mean = mean(jaccard, na.rm=TRUE)) %>% 
  inner_join(., coords, by= c('bird1' = 'nestbox')) %>% 
  select(-`box type`)



#TODO================================================================================================= add areas in woods


```

## Plots (distances)
```{r}
# Plot spatial distance vs acoustic distance (by bird)
distances_by_bird %>% 
  # filter_at(vars(starts_with("bird")), all_vars(str_detect(., pattern = "MP"))) %>%
  ggplot(aes(x= s_dist, y= mean_a_dist)) + 
  geom_point(size=0.6, alpha=0.6) + 
  geom_smooth(method = 'gam', colour='white') +
  theme(aspect.ratio = 1)

# Plot spatial distance vs acoustic distance (by song type)
distances_by_shared_song %>%
  filter(cluster1 == cluster2) %>% 
  distinct(label, mean_a_dist, .keep_all = TRUE) %>% 
  group_by(cluster1) %>%
  filter(n() > 100) %>% 
  ungroup() %>% 
  ggplot(aes(x= s_dist, y= mean_a_dist, colour = as.factor(cluster1))) + 
  geom_point(size=0.6, alpha=0.6) + 
  geom_smooth(method = 'lm', se = FALSE) +
  theme(aspect.ratio = 1)


# Plot sharing/not sharing vs spatial distance
library(car)

sharing_df %>%
  group_by(area) %>%
  mutate(area = recode(area,'B' = 'Marley', 'EX' = 'Extra', 'MP' = 'Marley Plantation', 'O' = 'Broad Oak', 'SW' = 'Singing Way', 'W' = 'Great Wood')) %>% 
  filter(n() > 100) %>%
  mutate(n_shared = replace(n_shared, n_shared > 1, 1)) %>%
  filter(s_dist < 1500) %>%
  drop_na(area) %>%
  # filter(area =='MP') %>%
  ggplot(aes(x = s_dist, y = n_shared)) +
  geom_jitter(alpha = 0.2,
              height = 0.02,
              size = 2) +
  geom_smooth(
    method = "glm",
    method.args = list(family = "binomial"),
    colour = 'black'
  ) +
  theme(
    panel.background = element_rect(fill = '#f2f1f0', colour = NA),
    panel.grid.minor = element_blank(),
    panel.grid.major.x = element_blank(),
    axis.ticks.y = element_blank(),
    axis.ticks.x = element_blank(),
    text = element_text(size = 15),
    legend.position = "none",
    aspect.ratio = 1.8,
    strip.background = element_rect(fill="white"),
    strip.text = element_text(colour = 'black', size = 15, vjust = 1.2),
    plot.title = element_text(hjust = 0.5)
  ) +
  labs(y = 'Probability of sharing a song\n',
       x = "\nDistance (m)",
       title = "Song sharing vs distance, by area of the Woods\n") +
  facet_grid(cols = vars(area), shrink = TRUE)



sharing_df %>% 
  # mutate(n_shared = replace(n_shared, n_shared >1, 1)) %>% 
  filter(s_dist < 1000) %>%
  # filter_at(vars(starts_with("bird")), all_vars(str_detect(., pattern = "MP"))) %>%
  ggplot(aes(x= s_dist, y= jaccard)) + 
  geom_point(alpha = 0.01) +
  geom_smooth(method = "gam") +
  # geom_point(size=0.6, alpha=0.6) + 
  theme(aspect.ratio = 1)


sharing_df %>% 
  # mutate(n_shared = replace(n_shared, n_shared >1, 1)) %>% 
  filter(s_dist < 1000) %>%
  filter(area == 'W') %>% 
  ggplot(aes(x= s_dist, y= jaccard)) + 
  geom_point(alpha = 0.01) +
  geom_smooth(method = "lm") +
  geom_point(size=0.6, alpha=0.6) + 
  theme(aspect.ratio = 1)


# Plot spatial distribution of average song sharing
cc <-
  scales::div_gradient_pal("#005ba1", "#8f8563", "#c94000", "Lab")(seq(0, 1, length.out = nrow(unique(mean_jaccard[c("mean")]))))

library(colorspace)

mean_jaccard %>% 
  ggplot(aes(x = x, y = y, colour = mean)) + 
  geom_point(size = 4) + 
  scale_colour_continuous_sequential(palette = 'Red-Blue') +
  theme(aspect.ratio = 1) +
  theme(
  panel.background = element_rect(fill = '#808080', colour = NA),
  panel.grid.major = element_blank(),
  panel.grid.minor = element_blank(),
  axis.ticks.y = element_blank(),
  axis.ticks.x = element_blank()
)



```

# Prob of sharing vs distance, plot
```{r}
sharing_df %>%
  mutate(n_shared = replace(n_shared, n_shared > 1, 1)) %>%
  filter(s_dist < 1000) %>%
  # filter(area =='MP') %>%
  ggplot(aes(x = s_dist, y = n_shared)) +
  geom_jitter(alpha = 0.1,
              height = 0.02,
              size = 0.5) +
  geom_smooth(
    method = "glm",
    method.args = list(family = "binomial"),
    colour = 'black'
  ) +
  theme(
    panel.background = element_rect(fill = '#f2f1f0', colour = NA),
    panel.grid.minor = element_blank(),
    panel.grid.major.x = element_blank(),
    axis.ticks.y = element_blank(),
    axis.ticks.x = element_blank(),
    text = element_text(size = 15),
    legend.position = "none",
    aspect.ratio = 1.5,
    strip.background = element_rect(fill="white"),
    strip.text = element_text(colour = 'black', size = 15, vjust = 1.2),
    plot.title = element_text(hjust = 0.5)
  ) +
  labs(y = 'Probability of sharing a song\n',
       x = "\nDistance (m)",
       title = "Song sharing vs distance\n")
```

# Graph

## Build graph and layout
```{r}

grph = melt(shared_matrix, varnames = c("bird1", "bird2")) %>% 
  as_tibble() %>% 
  rename(bird1 = bird2, bird2 = bird1) %>% 
  left_join(., spatial_dist_data) %>% 
  drop_na() %>% 
  rename(weight = value, from = bird1, to = bird2) %>% 
  filter(weight != 0) %>% filter(s_dist < 1000) # %>% mutate(weight = 1) # 'remove' weigths


# Remove symmetric pairs
cols = c(1,2)
n_grph = grph[,cols]
for (i in 1:nrow(grph)){
    n_grph[i, ] = sort(grph[i,cols])
}
grph = grph[!duplicated(n_grph),]

graph = as_tbl_graph(grph)
nodes = graph %>% activate(nodes) %>% as_tibble() %>% pull()

# Get nestbox coordinates
nestbox_coords = read_csv(coords_dir) %>% filter(nestbox %in% nodes) # only keep relevant birds
new_order <-
  sapply(nodes, function(x, nestbox_coords) {
    which(nestbox_coords$nestbox == x)
  }, nestbox_coords)
coordinates <- nestbox_coords[new_order,] %>% distinct(nestbox, .keep_all = TRUE)

graph = graph %>% mutate(x = coordinates$x, y =  coordinates$y)

```

## Plot graph
```{r}
# Plot as such

ggraph(graph,  x = x, y = y) + 
  geom_edge_link(alpha = .4, colour='white', edge_width=.04) +
  geom_node_point() +
  theme_graph(background = 'grey20') +
  coord_fixed()

ggraph(graph,  layout='stress') + 
  geom_edge_link(alpha = .7, colour='white', edge_width=.1) +
  geom_node_point() +
  theme_graph(background = 'grey20')

ggraph(dendrogram, 'dendrogram') + 
  geom_edge_diagonal()

  geom_edge_link(alpha = .7, colour='white', edge_width=.1) +
  geom_node_point() +
  theme_graph(background = 'grey20')

ggraph(graph,  x = x, y = y) +
  geom_edge_link(alpha = .07, colour='white', aes(width = weight)) +
  geom_node_point() +
  theme_graph(background = 'grey20') +
  coord_fixed()

```



# Acoustic vs spatial distance
```{r}

space_dist_matrix = as.matrix(dist(coords[0:2], upper = T))
rownames(space_dist_matrix) = birds
colnames(space_dist_matrix) = birds
spatial_dist_data <- as.dist(space_dist_matrix)

# Convert to dataframe
spatial_dist = as_tibble(melt(space_dist_matrix, varnames = c("X1", "X2"))) %>% rename(s_dist = value)
rm(space_dist_matrix, spatial_dist_data)

# Join distances
df = inner_join(spatial_dist, acoustic_dist) %>% 
  rename(key1 = X1, key2 = X2)


# Add cluster membership
dplyr::inner_join(df, cluster_m, by = 'key2')

k1 = cluster_membership %>% select(bird, cluster, file) %>% rename(key1 = bird, cluster1 = cluster, file1 = file)
k2 = k1 %>% rename(key2 = key1, cluster2 = cluster1)

df_complete = left_join(df, k1, by = 'key1')

df_complete = left_join(df_complete, k2, by = 'key2') %>% 
  mutate(cluster1 = cluster.x, key1 = key1.x) %>% 
  select(-c(cluster.y, key1.y, key1.x, cluster.x))  %>% 
  mutate(cluster = case_when(cluster1 == cluster2 ~ cluster1))

# Plot
cc <-
  scales::div_gradient_pal("#000000", "#6e6e6e", "#b5b5b5", "Lab")(seq(0, 1, length.out =
                                                                         nrow(unique(df_complete[c("cluster")]))))

scale_color_manual(values = cc) +

df_complete %>% filter(spatial_dist != 0) %>% drop_na() %>% #filter(cluster==1) %>% 
  #sample_n(50000, replace = FALSE) %>%
  ggplot(aes(
    x = spatial_dist,
    y = acoustic_dist,
    colour = as.factor(cluster)
  )) +
  geom_smooth(method = "lm", fill = NA) +
  geom_point(size = 0.5, alpha = 0.3) +
  #scale_y_log10(breaks = scales::log_breaks(n = 10)) +
  #annotation_logticks(sides = "b") +
  theme(aspect.ratio=1) +
  scale_color_manual(values = cc) +
  theme(
    panel.background = element_rect(fill = '#f2f1f0', colour = NA),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.ticks.y = element_blank(),
    axis.ticks.x = element_blank(),
    legend.position = "none"
  )

```

# Plot voronoi neighbours

```{r}
# library(sp); library(rgeos); library(deldir)

# http://www.spatialecology.com/gme/rdeldir.htm

```


```{r}
# track harmonic frequencu contour

file = '/media/nilomr/SONGDATA/processed/GRETI_HQ_2020_joined_notes_test/WAV/B3-545-3.wav'
file = '/media/nilomr/SONGDATA/processed/GRETI_HQ_2020_joined_notes_test/WAV/B3-545-1.wav'
wave = tuneR::readWave(file)

kk = track_harm(
  wave,
  wl = 512,
  wn = "hanning",
  ovlp = 70,
  fftw = FALSE,
  at = NULL,
  tlim = NULL,
  threshold = 5,
  clip = NULL,
  plot = TRUE,
  xlab = "Times (s)",
  ylab = "Frequency (kHz)",
  adjust.wl = TRUE,
  dfrq = TRUE
)



# plot spectrogram

spectro(sm_sng, grid = F, scale = F, f = f, ovlp = ovlp, palette = reverse.topo.colors, 
        collevels = cl, wl = wl, osc = F, flim = flm, 
        main = "warbleR's 'track_harm'")
```

# loop over df, progress bar example

```{r}
pb <-
  progress::progress_bar$new(total = length(cluster_membership$bird))

c_list <- list()

# Get cluster numbers per bird into a named list - or whatever it's called in R
for (indv in unique(cluster_membership$bird)) {
  c_list[[indv]] = cluster_membership %>% filter(bird == indv) %>% select(cluster) %>% unique () %>% deframe()
}
# Now count how many shared clusters per pair of birds
for (indv1 in unique(cluster_membership$bird)) {
  c_list[[indv1]]
}
  
  for (indv2 in unique(cluster_membership$bird)) {
    cluster_membership %>% filter(bird == indv)

  }
  pb$tick()
}
```

