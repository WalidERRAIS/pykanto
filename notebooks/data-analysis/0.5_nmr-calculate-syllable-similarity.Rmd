---
title: "Build RF similarity matrix for each note in the dataset"
author: "Nilo Merino Recalde<br>"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  github_document:
    toc: true
    toc_depth: 4
editor_options:
  chunk_output_type: console
---
<br>

# Settings and paths
```{r setup}
# Knitr settings: 
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
knitr::opts_chunk$set(echo = TRUE, eval = FALSE)
options(scipen = 999)
```

```{r}
# Code to calculate acoustic distances
#NOTE: this code will not make new measurements, calculate distances, etc, 
# if the corresponding output files already exist; 
# if you want to recalculate, delete the files before running

# Settings and paths --------------------------------------
# # clear the R workspace
# rm(list = ls())

x <- gc()
x <- c(
    "parallel",
    "vegan",
    "bioacoustics",
    "warbleR" ,
    "ggplot2",
    "Rraven",
    "cluster",
    "randomForest",
    "MASS",
    "fossil",
    "pbapply",
    "adehabitatHR",
    "Sim.DiffProc",
    "caret",
    "e1071",
    "tidyverse",
    "pracma",
    'dtwclust',
    'fastcluster',
    'dynamicTreeCut',
    'dbscan',
    'ggraph',
    'tidygraph',
    'progressr',
    'reshape2',
    'Matrix'
  )



# load packages 
aa <- lapply(x, function(y) {
  if (!y %in% installed.packages()[, "Package"])  {
    install.packages(y)
  }
  try(require(y, character.only = T), silent = T)
})

# Paths
root.dir = rprojroot::find_rstudio_root_file()
# dataset_name <-  "GRETI_HQ_2020_joined_notes_test" #! remove _test after done #!
dataset_name <-  "GRETI_HQ_2020_joined_notes" #! change to this if not test

data_dir <-  file.path(root.dir, "data", "processed", dataset_name, 'WAV')
out_dir = file.path(root.dir, "data", 'note_dfs', dataset_name)
coords_dir = file.path(getwd(), "resources", "nestboxes", "nestbox_coords.csv")
dom_freqs_name <- file.path(out_dir, 'dominant_frequencies.RDS')
dtw_dist_name <- file.path(out_dir, 'dtw_dist.RDS')

est.file.name <- file.path(out_dir, 'selection_table.RDS')
specs_dir <-  file.path(out_dir, 'spectrograms')

if (!dir.exists(specs_dir)) {
  dir.create(specs_dir, recursive = TRUE)
}

ncores = parallel::detectCores() - 1


# WarbleR options
warbleR_options(
  wav.path = data_dir,
  f = 22050,
  wl = 512,
  flim = c(2, 8.5),
  ovlp = 95,
  bp = c(2, 8.5),
  parallel = ncores
)

# Functions
stdize = function(x, ...) {(x - min(x, ...)) / (max(x, ...) - min(x, ...))}
```

# Make or load selection table
```{r}

if (file.exists(est.file.name)) {
  load(est.file.name)
} else {
  wi <- wav_info()
  summary(wi)
  est <- selection_table(whole.recs = T, extended = T, confirm.extended = F)
  save(est,file=est.file.name)
}

```

# Extract dominant frequencies
```{r}
#DTW
# dom_freqs$sound.files <-
#   lapply(dom_freqs$sound.files, function(x)
#     gsub("\\..*", "", x))

# Extract dominant frequency, save

if (file.exists(dom_freqs_name)) {
  load(dom_freqs_name)

} else {
  dom_freqs <- dfts(est,
      pb = TRUE,
      parallel = ncores,
      img = T,
      threshold.time = 3,
      threshold.freq = 3,
      fsmooth = 0.2,
      clip.edges = TRUE,
      track_harm = TRUE, 
      length.out = 20)
  
  save(dom_freqs, file=dom_freqs_name)
}
```

# Calculate DTW distances
```{r}
# dom_freqs %>% slice(36) %>% gather() %>% slice(3:nrow(.)) %>% select(value) %>%  plot() # check one trace

# Calculate DTW distances, save
if (file.exists(dtw_dist_name)) {
  load(dtw_dist_name)
} else {
  with_progress(system.time(dtw_dist <- proxy::dist(dom_freqs[c(-1,-2)], method = "DTW_BASIC", norm = "L2", window.size = 10))) # series are of same length so distances are symmetric even with a window applied
  dtw_dist_matrix = as.matrix(dtw_dist) %>% stdize() # convert to matrix and range 0-1
  rownames(dtw_dist_matrix) = dom_freqs$sound.files
  colnames(dtw_dist_matrix) = dom_freqs$sound.files
  save(dtw_dist_matrix, file=dtw_dist_name)
}

# heatmap(dtw_dist_matrix)
dtw_dist_matrix[!is.finite(dtw_dist_matrix)] # check that there are no infinites

```

# Clustering
```{r}
# Hierarchical clustering
DTWdist = as.dist(dtw_dist_matrix)
dendrogram = hclust(DTWdist, method = "average")
clusters <-
  cutreeDynamic(
    dendrogram,
    distM = as.matrix(DTWdist),
    deepSplit = 3,
    # This works well (i.e. cluster membership makes sense; 
    # 3 leads to 1 cluster per song type/bird, 
    # 1 to obviously different songs in same cluster)
    minClusterSize = 4, # Set to smallest sample size for any song type
    method = 'hybrid',
    verbose = 4
  )

print(str_glue('Number of clusters: {length(unique(clusters))}'))
cluster_membership = tibble(file = dom_freqs$sound.files, cluster = clusters) %>% 
  mutate(name = lapply(file, function(x)
  gsub("\\..*", "", x))) %>% 
  mutate(note = gsub('-[^-]*$', '', name), bird = gsub('-[^-]*', '', name))

# HDBSCAN clustering
# detects song types by bird very well, but this is not what we want - need a more relaxed solution, like above
# hdbscan_clusters = hdbscan(DTWdist, minPts = 4)
# plot(hdbscan_clusters, show_flat = TRUE)
# plot(DTWdist, col=hdbscan_clusters$cluster+1L, cex = .5)
# plot(hdbscan_clusters$hc, main="HDBSCAN* Hierarchy")
# cluster_membership = cluster_membership %>% mutate(hdbscan_cluster = hdbscan_clusters$cluster)
```

# Graph
## Prepare data
```{r}
# Build song-sharing matrix
summary_songs = cluster_membership %>% distinct(note, cluster, .keep_all = TRUE)
match_matrix = as.matrix(dist(summary_songs$cluster, upper=TRUE, diag=FALSE))
match_matrix[match_matrix > 0] <- NA
match_matrix[match_matrix == 0] <- 1
match_matrix[is.na(match_matrix)] <-  0
diag(match_matrix) <- 0
rownames(match_matrix) = summary_songs$bird
colnames(match_matrix) = summary_songs$bird

# Number of shared songs (losing info about which)
shared_matrix = rowsum(match_matrix, row.names(match_matrix), reorder = FALSE)
shared_table = as_tibble(shared_matrix, .name_repair="minimal")
shared_matrix = as.matrix(do.call(cbind, by(t(shared_table),INDICES=names(shared_table),FUN=colSums)))
rownames(shared_matrix) = colnames(shared_matrix)

diag(shared_matrix) <- 0
shared_matrix = as.matrix(tril(shared_matrix))
```

## Build graph and layout
```{r}

grph = melt(shared_matrix, varnames = c("from", "to")) %>% 
  rename(weight = value) %>% filter(weight != 0) %>% 
  mutate(weight = 1) # 'remove' weigths

# Remove symmetric pairs
cols = c(1,2)
n_grph = grph[,cols]
for (i in 1:nrow(grph)){
    n_grph[i, ] = sort(grph[i,cols])
}
grph = grph[!duplicated(n_grph),]

graph = as_tbl_graph(grph)
nodes = graph %>% activate(nodes) %>% as_tibble() %>% pull()

# Get nestbox coordinates
nestbox_coords = read_csv(coords_dir) %>% filter(nestbox %in% nodes) # only keep relevant birds
new_order <-
  sapply(nodes, function(x, nestbox_coords) {
    which(nestbox_coords$nestbox == x)
  }, nestbox_coords)
coords <- nestbox_coords[new_order,] %>% distinct(nestbox, .keep_all = TRUE)

graph = graph %>% mutate(x = coords$x, y =  coords$y)

```

## Plot graph
```{r}
# Plot as such

ggraph(graph,  x = x, y = y) + 
  geom_edge_link(alpha = .7, colour='white', edge_width=.04) +
  geom_node_point() +
  theme_graph(background = 'grey20') +
  coord_fixed()

ggraph(graph,  layout='stress') + 
  geom_edge_link(alpha = .7, colour='white', edge_width=.1) +
  geom_node_point() +
  theme_graph(background = 'grey20')


ggraph(dendrogram, 'dendrogram') + 
  geom_edge_diagonal()

  geom_edge_link(alpha = .7, colour='white', edge_width=.1) +
  geom_node_point() +
  theme_graph(background = 'grey20')

# ggraph(graph,  x = x, y = y) + 
#   geom_edge_link(alpha = .02, colour='white', aes(width = weight)) +
#   geom_node_point() +
#   theme_graph(background = 'grey20')

```

# Acoustic distance vs spatial distance

```{r}

birds = cluster_membership$bird %>% unique()

# Prepare DTW distances
rownames(dtw_dist_matrix) = cluster_membership$file
colnames(dtw_dist_matrix) = cluster_membership$file
acoustic_dist = as_tibble(melt(dtw_dist_matrix, varnames = c("file", "file2"))) %>% rename(a_dist = value)

cluster_membership2 = cluster_membership %>% rename(file2 = file)

acoustic_df = inner_join(acoustic_dist, cluster_membership, by = 'file') %>% 
  inner_join(.,cluster_membership2, by = 'file2', suffix = c("", "2")) %>% 
  group_by(note, note2) %>% 
  mutate(mean_a_dist = mean(a_dist)) %>% 
  distinct(mean_a_dist, note2, .keep_all = TRUE)

acoustic_df_mean = acoustic_df %>% 
  filter(!(note == note2)) %>%
  group_by(bird, bird2) %>%
  mutate(mean_a_dist = mean(a_dist)) 
  distinct(mean_a_dist, bird2, .keep_all = TRUE) #does this work??
  
  
# HERE ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

rm(acoustic_dist, dom_freqs, dendrogram, cluster_membership2); gc()

shared_matrix = as.matrix(do.call(cbind, by(t(shared_table),INDICES=names(shared_table),FUN=colSums)))

# Get nestbox coordinates
nest_coords = read_csv(coords_dir) %>% filter(nestbox %in% birds) # only keep relevant birds
new_order <-
  sapply(birds, function(x, nest_coords) {
    which(nest_coords$nestbox == x)
  }, nest_coords)
coords <- nest_coords[new_order,] %>% distinct(nestbox, .keep_all = TRUE)



```


# Acoustic vs spatial distance
```{r}

space_dist_matrix = as.matrix(dist(coords[0:2], upper = T))
rownames(space_dist_matrix) = birds
colnames(space_dist_matrix) = birds
spatial_dist_data <- as.dist(space_dist_matrix)

# Convert to dataframe
spatial_dist = as_tibble(melt(space_dist_matrix, varnames = c("X1", "X2"))) %>% rename(s_dist = value)
rm(space_dist_matrix, spatial_dist_data)

# Join distances
df = inner_join(spatial_dist, acoustic_dist) %>% 
  rename(key1 = X1, key2 = X2)


# Add cluster membership
dplyr::inner_join(df, cluster_m, by = 'key2')

k1 = cluster_membership %>% select(bird, cluster, file) %>% rename(key1 = bird, cluster1 = cluster, file1 = file)
k2 = k1 %>% rename(key2 = key1, cluster2 = cluster1)

df_complete = left_join(df, k1, by = 'key1')

df_complete = left_join(df_complete, k2, by = 'key2') %>% 
  mutate(cluster1 = cluster.x, key1 = key1.x) %>% 
  select(-c(cluster.y, key1.y, key1.x, cluster.x))  %>% 
  mutate(cluster = case_when(cluster1 == cluster2 ~ cluster1))

# Plot
cc <-
  scales::div_gradient_pal("#000000", "#6e6e6e", "#b5b5b5", "Lab")(seq(0, 1, length.out =
                                                                         nrow(unique(df_complete[c("cluster")]))))

df_complete %>% filter(spatial_dist != 0) %>% drop_na() %>% #filter(cluster==1) %>% 
  #sample_n(50000, replace = FALSE) %>%
  ggplot(aes(
    x = spatial_dist,
    y = acoustic_dist,
    colour = as.factor(cluster)
  )) +
  geom_smooth(method = "lm", fill = NA) +
  geom_point(size = 0.5, alpha = 0.3) +
  #scale_y_log10(breaks = scales::log_breaks(n = 10)) +
  #annotation_logticks(sides = "b") +
  theme(aspect.ratio=1) +
  scale_color_manual(values = cc) +
  theme(
    panel.background = element_rect(fill = '#f2f1f0', colour = NA),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.ticks.y = element_blank(),
    axis.ticks.x = element_blank(),
    legend.position = "none"
  )

```

# Plot voronoi neighbours

```{r}
# library(sp); library(rgeos); library(deldir)

# http://www.spatialecology.com/gme/rdeldir.htm

```


```{r}
# track harmonic frequencu contour

file = '/media/nilomr/SONGDATA/processed/GRETI_HQ_2020_joined_notes_test/WAV/B3-545-3.wav'
file = '/media/nilomr/SONGDATA/processed/GRETI_HQ_2020_joined_notes_test/WAV/B3-545-1.wav'
wave = tuneR::readWave(file)

kk = track_harm(
  wave,
  wl = 512,
  wn = "hanning",
  ovlp = 70,
  fftw = FALSE,
  at = NULL,
  tlim = NULL,
  threshold = 5,
  clip = NULL,
  plot = TRUE,
  xlab = "Times (s)",
  ylab = "Frequency (kHz)",
  adjust.wl = TRUE,
  dfrq = TRUE
)



# plot spectrogram

spectro(sm_sng, grid = F, scale = F, f = f, ovlp = ovlp, palette = reverse.topo.colors, 
        collevels = cl, wl = wl, osc = F, flim = flm, 
        main = "warbleR's 'track_harm'")
```

# loop over df, progress bar example

```{r}
pb <-
  progress::progress_bar$new(total = length(cluster_membership$bird))

c_list <- list()

# Get cluster numbers per bird into a named list - or whatever it's called in R
for (indv in unique(cluster_membership$bird)) {
  c_list[[indv]] = cluster_membership %>% filter(bird == indv) %>% select(cluster) %>% unique () %>% deframe()
}
# Now count how many shared clusters per pair of birds
for (indv1 in unique(cluster_membership$bird)) {
  c_list[[indv1]]
}
  
  for (indv2 in unique(cluster_membership$bird)) {
    cluster_membership %>% filter(bird == indv)

  }
  pb$tick()
}
```

